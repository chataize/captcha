@implements IDisposable
@inject PersistentComponentState ApplicationState
@inject CaptchaService CaptchaService

<div id="@_id"></div>

@code {
    /// <summary>
    /// Subscription used to persist state during server-side prerendering.
    /// </summary>
    private PersistingComponentStateSubscription _persistingSubscription;

    /// <summary>
    /// Unique ID to bind the DOM element to the JS widget instance.
    /// </summary>
    private int _id = Random.Shared.Next();

    /// <summary>
    /// Cached IP address from prerendering to reuse after hydration.
    /// </summary>
    private string? _ipAddress;

    /// <summary>
    /// Optional IP address override for verification requests.
    /// </summary>
    [Parameter]
    public string? IpAddress { get; set; }

    /// <summary>
    /// Optional site key override for widget rendering.
    /// </summary>
    [Parameter]
    public string? SiteKey { get; set; }

    /// <summary>
    /// Optional secret override for server-side verification.
    /// </summary>
    [Parameter]
    public string? Secret { get; set; }

    /// <summary>
    /// Desired widget theme.
    /// </summary>
    [Parameter]
    public CaptchaTheme Theme { get; set; }

    /// <summary>
    /// Desired widget size.
    /// </summary>
    [Parameter]
    public CaptchaSize Size { get; set; }

    /// <summary>
    /// Gets or sets whether the most recent verification succeeded.
    /// </summary>
    [Parameter]
    public bool IsVerified { get; set; }

    /// <summary>
    /// Two-way binding hook for <see cref="IsVerified"/>.
    /// </summary>
    [Parameter]
    public EventCallback<bool> IsVerifiedChanged { get; set; }

    /// <summary>
    /// Invoked when the widget opens.
    /// </summary>
    [Parameter]
    public EventCallback Opened { get; set; }

    /// <summary>
    /// Invoked when the widget closes.
    /// </summary>
    [Parameter]
    public EventCallback Closed { get; set; }

    /// <summary>
    /// Invoked when verification succeeds.
    /// </summary>
    [Parameter]
    public EventCallback Succeeded { get; set; }

    /// <summary>
    /// Invoked when the widget expires.
    /// </summary>
    [Parameter]
    public EventCallback Expired { get; set; }

    /// <summary>
    /// Invoked when the challenge expires.
    /// </summary>
    [Parameter]
    public EventCallback ChallengeExpired { get; set; }

    /// <summary>
    /// Invoked when the widget reports an error.
    /// </summary>
    [Parameter]
    public EventCallback<string> Error { get; set; }

    /// <summary>
    /// Disposes the persisting subscription when the component is removed.
    /// </summary>
    public void Dispose()
    {
        _persistingSubscription.Dispose();
    }

    /// <summary>
    /// Handles completion callbacks from the widget.
    /// </summary>
    /// <param name="token">hCaptcha response token.</param>
    /// <returns>A task that completes after verification and event callbacks.</returns>
    [JSInvokable]
    public async Task OnCaptchaCompleted(string token)
    {
        // Validate the token server-side before reporting success.
        IsVerified = await CaptchaService.VerifyTokenAsync(token, IpAddress ?? _ipAddress, SiteKey, Secret);

        if (IsVerifiedChanged.HasDelegate)
        {
            await IsVerifiedChanged.InvokeAsync(IsVerified);
        }

        if (Succeeded.HasDelegate && IsVerified)
        {
            await Succeeded.InvokeAsync();
        }
    }

    /// <summary>
    /// Handles widget open callbacks.
    /// </summary>
    /// <returns>A task that completes after invoking any listeners.</returns>
    [JSInvokable]
    public async Task OnCaptchaOpened()
    {
        if (Opened.HasDelegate)
        {
            await Opened.InvokeAsync();
        }
    }

    /// <summary>
    /// Handles widget close callbacks.
    /// </summary>
    /// <returns>A task that completes after invoking any listeners.</returns>
    [JSInvokable]
    public async Task OnCaptchaClosed()
    {
        if (Closed.HasDelegate)
        {
            await Closed.InvokeAsync();
        }
    }

    /// <summary>
    /// Handles widget expiration callbacks.
    /// </summary>
    /// <returns>A task that completes after state updates and callbacks.</returns>
    [JSInvokable]
    public async Task OnCaptchaExpired()
    {
        // Expiration invalidates any prior success.
        IsVerified = false;

        if (IsVerifiedChanged.HasDelegate)
        {
            await IsVerifiedChanged.InvokeAsync(IsVerified);
        }

        if (Expired.HasDelegate)
        {
            await Expired.InvokeAsync();
        }
    }

    /// <summary>
    /// Handles challenge expiration callbacks.
    /// </summary>
    /// <returns>A task that completes after state updates and callbacks.</returns>
    [JSInvokable]
    public async Task OnCaptchaChallengeExpired()
    {
        // Challenge expiration is distinct from widget expiration but still invalidates.
        IsVerified = false;

        if (IsVerifiedChanged.HasDelegate)
        {
            await IsVerifiedChanged.InvokeAsync(IsVerified);
        }

        if (ChallengeExpired.HasDelegate)
        {
            await ChallengeExpired.InvokeAsync();
        }
    }

    /// <summary>
    /// Handles widget error callbacks.
    /// </summary>
    /// <param name="code">Error code returned by the widget.</param>
    /// <returns>A task that completes after state updates and callbacks.</returns>
    [JSInvokable]
    public async Task OnCaptchaError(string code)
    {
        // Errors must clear the verified state to avoid stale success.
        IsVerified = false;

        if (IsVerifiedChanged.HasDelegate)
        {
            await IsVerifiedChanged.InvokeAsync(IsVerified);
        }

        if (Error.HasDelegate)
        {
            await Error.InvokeAsync(code);
        }
    }

    /// <summary>
    /// Initializes component state, capturing the IP during prerendering.
    /// </summary>
    protected override void OnInitialized()
    {
        base.OnInitialized();

        // Capture IP during prerender and persist it so the interactive render can reuse it.
        if (ApplicationState.TryTakeFromJson<string>("ipAddress", out var ipAddress))
        {
            _ipAddress = ipAddress;
        }
        else
        {
            _ipAddress = CaptchaService.IpAddress;
            _persistingSubscription = ApplicationState.RegisterOnPersisting(PersistData);
        }
    }

    /// <summary>
    /// Initializes the JS widget after the first render.
    /// </summary>
    /// <param name="firstRender">Whether this is the first render.</param>
    /// <returns>A task that completes after initialization.</returns>
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (firstRender)
        {
            // Initialize the hCaptcha widget once the container div exists.
            await CaptchaService.InitializeAsync(_id, DotNetObjectReference.Create(this), SiteKey, Theme, Size);
        }
    }

    /// <summary>
    /// Persists the IP address during prerendering.
    /// </summary>
    /// <returns>A completed task.</returns>
    private Task PersistData()
    {
        // Store IP so it survives the prerender -> interactive transition.
        ApplicationState.PersistAsJson("ipAddress", CaptchaService.IpAddress);
        return Task.CompletedTask;
    }
}
